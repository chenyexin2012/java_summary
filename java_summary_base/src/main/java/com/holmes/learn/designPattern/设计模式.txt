一、设计模式的分类

	总体来说设计模式分为三大类：
	
	创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
	
	结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
	
	行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、
						状态模式、访问者模式、中介者模式、解释器模式。
						
	其它模式：并发型模式和线程池模式
	
二、设计模式的六大原则

	1、开闭原则（Open Close Principle）
			对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。
	
	2、里氏代换原则（Liskov Substitution Principle）
			里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则
		中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，
		软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换
		原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的
		具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
		
	3、依赖倒转原则（Dependence Inversion Principle）
			这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

	4、接口隔离原则（Interface Segregation Principle）
			这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思
		，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方
		便。所以上文中多次出现：降低依赖，降低耦合。

	5、迪米特法则（最少知道原则）（Demeter Principle）
	
			为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能
		模块相对独立。
	
	6、合成复用原则（Composite Reuse Principle）
		原则是尽量使用合成/聚合的方式，而不是使用继承。
	
三、Java的设计模式
	1.工厂模式（Factory Method）
		通过建立一个工厂类来对实现同一接口的多个实现类统一的进行实例的创建。
		
		凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。
		
		1.1.普通工厂模式
			通过建立一个工厂类，来对实现同一接口的多个类按照各自需求进行实例的创建。
				public class SendFactory {
					public Sender produce(String type) {
						if ("mail".equals(type)) {
							return new MailSender();
						} else if ("sms".equals(type)) {
							return new SmsSender();
						} else {
							System.out.println("请输入正确的类型!");
							return null;
						}
					}
				}
				
		1.2.多个工厂方法模式
				通过在工厂类中建立多个方法来对实现同一接口的多个类按照各自需求进行实例的创建。可以防止在普通方法中因输入
			错误字符而导致对象创建失败。
			public class SendFactory1 {  
			
			    public Sender produceMail(){  
			        return new MailSender();  
			    }  
			      
			    public Sender produceSms(){  
			        return new SmsSender();  
			    }  
			}  	
	
		1.3.静态工厂方法模式
				通过在工厂类中建立多个静态方法，不需要创建工厂的实例就可以创建相应的对象。
			public class SendFactory2 {
		
				public static Sender produceMail(){
					return new MailSender();
				}
				
				public static Sender produceSms(){
					return new SmsSender();
				}
			}
	
	2.抽象工厂模式
			在工厂模式中，类的实例创建依赖于工厂，当时程序需要拓展时，就必须对原有的工厂类进行修改，这就违背的
		开闭原则。所以就要用到抽象工厂模式，对原有的工厂类进行进一步抽象，建立多个工厂类，在程序进行拓展时，只需
		要新增一个工厂类即可。
		public interface Provider {
			public Sender produce();
		}
		
		public class SendSmsFactory implements Provider{
		
			@Override
			public Sender produce() {
				return new SmsSender();
			}
		
		}
		
	3.单例模式（Singleton）		
			单例模式是java中非常常用的一个设计模式。使用单例模式，可以保证在JVM中，该类的对象只有一个。
		在系统的开发过程中，有些类需要频繁创建，而对与一些大型的对象，使用单例模式可以节省大量的系统资源，
		同时可以减少频繁的new操作，降低系统内存使用频率，减轻GC压力。在一些大型的交易系统中，使用单例模
		式可以使得核心可以控制整个交易流程。
		
		最简单的单例模式实现方法如下：
		
			public class Singleton {
				 /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */
				private static Singleton singleton = null;
				/**
				 *  私有构造方法，防止对象初始化
				 */
				private Singleton() {
				}
				
				public static Singleton getInstance() {
					if(singleton == null) {
						singleton = new Singleton();
					}
					return singleton;
				}
			}
		
		使用此种方式可以满足使用单例模式的基础要求，但是在多线程环境下，无法保证正常使用。因此可以尝试在getInstance
		上添加synchronized关键字。
			public static synchronized Singleton getInstance() {
				if(singleton == null) {
					singleton = new Singleton();
				}
				return singleton;
			}
		但是此方法在每次调用getInstance获取对象时，synchronized都会锁住singleton对象，从而影响系统性能。再次
		改进方法如下：
			public static Singleton getInstance() {
				if(singleton == null) {
					synchronized (Singleton.class) {
						if(singleton == null) {
							singleton = new Singleton();
						}
					}
				}
				return singleton;
			}
		使用此方式，会在首次初始化对象时锁住对象，从而保证了性能。（为了防止指令重排序，要给singleton加上volatile关键字）
		可以通过一个静态的内部内来维护单例的实现
		    private static class SingletonFactory {  
		        private static Singleton instance = new Singleton();  
		    }  
		    public static Singleton getInstance() {
		    	return SingletonFactory.instance;
		    }	
				
	4.建造者模式（Builder）
	
		建造者模式的角色：
		1.	Builder：为创建一个产品对象的各个部件定义抽象接口。
		2.	ConcreteBuilder:实现Builder接口以构造和装配该产品的各个部件。定义并明确它所创建的表示，
			 并提供一个检索产品的接口。
		3. 	Director:构造一个使用Builder接口的对象。
		4.	Product:表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包
			含定义组成部件的类，包括将这些部件装配成最终产品的接口。				
	
	5.原型模式（Prototype）
	
	
	6.适配器模式（Adapter）
		适配器模式为了消除由于接口的不匹配造成的类的兼容性问题，将某个接口转换成满足客户端需求的另一个接口。
		
		6.1 类的适配器模式
			当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新的类，继承原有的类，
		并实现新的接口。
		
		6.2对象的适配器模式
			当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在
		Wrapper类的方法中，调用实例的方法就行。
		
		6.3接口的适配器模式
			在实际的开发过程中，有时候在使用一个接口时，通常不需要实现接口中的大部分方法，这时可以通过使用一个
		抽象类Wrapper来实现所有接口，并在实际使用的过程中，继承抽象类Wrapper。
	
	7.装饰模式（Decorator）
		装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象
	持有被装饰对象的实例。
	
	8.代理模式（Proxy）
		对已有的对象添加一个代理对象，并使得代理对象中包含对原有对象的引用。
		
		装饰模式与代理模式的区别：
			a.装饰模式动态的为对象增加功能，而代理模式更多的是限制对对象的操作。
			b.装饰模式中由客户指定需要被装饰的对象，而代理模式中在编译期间完成对象与代 之间的关联，对客户不透明。
		
	9.外观模式（Facade）
		为了降低客户端与子系统之间的耦合度，引入一个外观类来简化客户端与子系统之间的调用，为多个子系统提供一个统一的入
	口。
	
	10.桥接模式（Bridge）	
		将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模
	式或接口(Interface)模式。	
	
	在桥接模式结构图中包含如下几个角色：

	●Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接
	口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务
	方法。
	
	●RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现
	了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。
	
	●Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口
	可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。
	Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方
	法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。
	
	●ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的
	不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。			
						
	11.组合模式（composite）
		组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即
	容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。
	
	在组合模式结构图中包含如下几个角色：

    ● Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有
	行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。				
						
	● Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些
	访问及管理子构件的方法，可以通过异常等方式进行处理。			
	
	● Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容
	器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法
	中可以递归调用其子节点的业务方法。
						
						
	12.享元模式（Flyweight）
	
	● Flyweight（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界
	提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。

    ● ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空
        间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。

    ● UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设
        计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。

    ● FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对
        象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；
        当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返
        回新创建的实例并将其存储在享元池中。
        
	13.策略模式（strategy）
	
		策略模式通过定义一系列算法，并封装每个算法，使得它们可以相互替换，同时不影响客户端的结果，实现算法与功能分离。
	
	●　环境(Context)角色：持有一个Strategy的引用。

　　 ●　抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。

　　 ●　具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。


	14.模板方法模式（template method）
	
		定义一个算法的骨架，并将算法不同步骤延迟到子类中去实现，使得子类不需要改变算法的结构且能够根据需求改变某些
	特定步骤。
	
	
	15.观察者模式（Observer）
	
		在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。
		
		观察者模式的四个角色：
		
		抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量
	的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
		
		抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
		
		具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。
		
		具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。
	
	
	16.迭代器模式（Iterator）
	
		顺序访问聚集中的对象。在集合类中只用较多。
		
	17.	责任链模式（chain of responsibility）
		有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该
	请求。
	
	18. 命令模式（Command） 
		将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可
	撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。
	
	19. 备忘录模式（Memento）
		对对象某个时刻的状态进行拷贝，以便于之后将对象恢复到之前的状态。
		
	20. 状态模式（state）
		在对象的状态发生改变的同时，改变它的行为。
	
	21. 访问者模式（Visitor）
	
	22. 中介者模式（Mediator）
		
	23. 解释器模式（Interpreter）
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
						